// Code generated by github.com/ohanan/single-goroutine-gen. DO NOT EDIT.
package testdata
import (
	"fmt"
	"reflect"
	"unsafe"
)
func NewProto(service Proto) (_ Proto, close func()) {
	s := &_genServiceProto{
		delegate:  service,
		msgChan:   make(chan any),
		respChan:  make(chan struct{}, 1),
		closeChan: make(chan struct{}),
	}
	s.initCopy()
	go s.run()
	return s, func() { s.closeChan <- struct{}{} }
}
type _genServiceProto struct {
	delegate   Proto
	msgChan    chan any
	respChan   chan struct{}
	closeChan  chan struct{}
	flagOffset uintptr
}
func (_x *_genServiceProto) initCopy() {
	if t := reflect.TypeOf(reflect.Value{}); t.Kind() == reflect.Struct {
		for i := 0; i < t.NumField(); i++ {
			if f := t.Field(i); f.Name == "flag" && f.Type.Kind() == reflect.Uintptr {
				_x.flagOffset = f.Offset
				return
			}
		}
	}
	panic("failed to init flag offset")
}
func (_x *_genServiceProto) disableRO(v *reflect.Value) {
	flags := (*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + _x.flagOffset))
	*flags &^= (1 << 5) | (1 << 6)
}
func (_x *_genServiceProto) copy(src any) any {
	v := reflect.ValueOf(src)
	if v.Kind() == reflect.Invalid {
		return src
	}
	return _x.recursiveCopy(v, make(map[uintptr]map[string]reflect.Value)).Interface()
}
func (_x *_genServiceProto) recursiveCopy(v reflect.Value, pointers map[uintptr]map[string]reflect.Value) reflect.Value {
	switch v.Kind() {
	case reflect.Chan, reflect.Func, reflect.Pointer, reflect.Map, reflect.UnsafePointer, reflect.Interface, reflect.Slice:
		if v.IsNil() {
			return v
		}
	}
	switch v.Kind() {
	case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32,
		reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
		reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64,
		reflect.Complex64, reflect.Complex128, reflect.String:
		return v
	case reflect.Array:
		dst := reflect.New(v.Type()).Elem()
		for i := 0; i < v.Len(); i++ {
			dst.Index(i).Set(_x.recursiveCopy(v.Index(i), pointers))
		}
		return dst
	case reflect.Interface:
		return _x.recursiveCopy(v.Elem(), pointers)
	case reflect.Map:
		dst := reflect.MakeMap(v.Type())
		for _, key := range v.MapKeys() {
			elem := v.MapIndex(key)
			elemDst := _x.recursiveCopy(elem, pointers)
			dst.SetMapIndex(key, elemDst)
		}
		return dst
	case reflect.Ptr:
		typeName := v.Type().String()
		ptr := v.Pointer()
		if dstMap, ok := pointers[ptr]; ok {
			if dst, ok := dstMap[typeName]; ok {
				return dst
			}
		}
		dst := reflect.New(v.Type().Elem())
		if pointers[ptr] == nil {
			pointers[ptr] = make(map[string]reflect.Value)
		}
		pointers[ptr][typeName] = dst
		dst.Elem().Set(_x.recursiveCopy(v.Elem(), pointers))
		return dst
	case reflect.Slice:
		dst := reflect.MakeSlice(v.Type(), v.Len(), v.Cap())
		for i := 0; i < v.Len(); i++ {
			dst.Index(i).Set(_x.recursiveCopy(v.Index(i), pointers))
		}
		return dst
	case reflect.Struct:
		dst := reflect.New(v.Type()).Elem()
		for i := 0; i < v.NumField(); i++ {
			elem := v.Field(i)
			_x.disableRO(&elem)
			elemDst := _x.recursiveCopy(elem, pointers)
			dstField := dst.Field(i)
			_x.disableRO(&dstField)
			dstField.Set(elemDst)
		}
		return dst
	default:
		return reflect.Zero(v.Type())
	}
}
func (_x *_genServiceProto) UpdateAndGet(p0 map[int]int) (map[int]int, error) {
	msg := &_genMsgUpdateAndGet{p0: p0}
	_x.sendAndWait(msg)
	return msg.r0, msg.r1
}
func (_x *_genServiceProto) sendAndWait(msg any) {
	_x.msgChan <- msg
	<-_x.respChan
}
type (
	_genMsgUpdateAndGet struct {
		p0 map[int]int
		r0 map[int]int
		r1 error
	}
)
func (_x *_genServiceProto) run() {
	for {
		select {
		case <-_x.closeChan:
			close(_x.msgChan)
			close(_x.respChan)
			close(_x.closeChan)
			return
		case receivedMsg := <-_x.msgChan:
			switch msg := receivedMsg.(type) {
			case *_genMsgUpdateAndGet:
				_x.wrap(&msg.r1, func() {
					msg.r0, msg.r1 = _x.delegate.UpdateAndGet(msg.p0)
					msg.r0, msg.r1 = _x.copy(msg.r0).(map[int]int), _x.copy(msg.r1).(error)
				})
			}
			_x.respChan <- struct{}{}
		}
	}
}
func (_x *_genServiceProto) wrap(err *error, f func()) {
	defer func() {
		if r := recover(); r != nil {
			if rr, ok := r.(error); ok {
				*err = rr
			} else {
				*err = fmt.Errorf("panic: %v", r)
			}
		}
	}()
	f()
}
