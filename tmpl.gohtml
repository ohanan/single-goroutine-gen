{{- /*gotype: github.com/ohanan/single-goroutine-gen.Data*/ -}}// Code generated by github.com/ohanan/single-goroutine-gen. DO NOT EDIT.
package {{.Package}}
import (
"fmt"
"reflect"
"unsafe"
{{range .Imports}}
    "{{.}}"
{{end}}
)
{{$client := print "_genClient" .Client}}
{{$originalClient:= .Client}}
{{$service := print "_genService" .Service}}
func New{{.Service}}(service {{.Service}}) {{.Service}} {
s:= &{{$service}}{
delegate: service,
{{if .ClientID}} clients: make(map[{{.ClientID}}]*{{$client}}), {{end}}
msgChan: make(chan any),
respChan: make(chan struct{}, 1),
closeChan: make(chan struct{}),
}
s.initCopy()
go s.run()
return s
}
{{if .ClientID}}
    type {{$client}} struct {
    service *{{$service}}
    delegate {{.Client}}
    closeChan chan struct{}
    msgChan chan any
    }
    {{range .ClientMethods}}
        func(_x *{{$client}}) {{.Name}}({{range $i, $x := .Param}}{{if $i}}, {{end}}p{{$i}} {{$x}}{{end}}){
        _x.send(&_genNotify{{.Name}}{ {{range $i, $x := .Param}}{{if $i}}, {{end}}p{{$i}}: p{{$i}}{{end}}})
        }
    {{end}}
    func (_x *{{$client}}) send(msg any) {
    _x.msgChan <- _x.service.copy(msg)
    }

    func (_x *{{$client}}) run() {
    for {
    select {
    case <-_x.closeChan:
    close(_x.msgChan)
    close(_x.closeChan)
    return
    case receivedMsg := <-_x.msgChan:
    switch msg := receivedMsg.(type) {
    {{range .ClientMethods}}case *_genNotify{{.Name}}:
    _x.delegate.{{.Name}}({{range $i, $x := .Param}}{{if $i}}, {{end}}msg.p{{$i}}{{end}})
    {{end}}}
    }
    }
    }
{{end}}
type {{$service}} struct {
delegate {{.Service}}
{{if .ClientID}}clients map[{{.ClientID}}]*{{$client}}{{end}}
msgChan chan any
respChan chan struct{}
closeChan chan struct{}
flagOffset uintptr
}

func (_x *{{$service}}) initCopy() {
if t := reflect.TypeOf(reflect.Value{}); t.Kind() == reflect.Struct {
for i := 0; i < t.NumField(); i++ {
if f := t.Field(i); f.Name == "flag" && f.Type.Kind() == reflect.Uintptr {
_x.flagOffset = f.Offset
return
}
}
}
panic("failed to init flag offset")
}
func (_x *{{$service}}) disableRO(v *reflect.Value) {
flags := (*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + _x.flagOffset))
*flags &^= (1 << 5) | (1 << 6)
}

func (_x *{{$service}}) copy(src any) any {
v := reflect.ValueOf(src)
if v.Kind() == reflect.Invalid {
return src
}
return _x.recursiveCopy(v, make(map[uintptr]map[string]reflect.Value)).Interface()
}

func (_x *{{$service}}) recursiveCopy(v reflect.Value, pointers map[uintptr]map[string]reflect.Value) reflect.Value {
switch v.Kind() {
case reflect.Chan, reflect.Func, reflect.Pointer, reflect.Map, reflect.UnsafePointer, reflect.Interface, reflect.Slice:
if v.IsNil() {
return v
}
}
switch v.Kind() {
case reflect.Bool, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32,
reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32,
reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64,
reflect.Complex64, reflect.Complex128, reflect.String:
return v
case reflect.Array:
dst := reflect.New(v.Type()).Elem()
for i := 0; i < v.Len(); i++ {
dst.Index(i).Set(_x.recursiveCopy(v.Index(i), pointers))
}
return dst
case reflect.Interface:
return _x.recursiveCopy(v.Elem(), pointers)
case reflect.Map:
dst := reflect.MakeMap(v.Type())
for _, key := range v.MapKeys() {
elem := v.MapIndex(key)
elemDst := _x.recursiveCopy(elem, pointers)
dst.SetMapIndex(key, elemDst)
}
return dst
case reflect.Ptr:
typeName := v.Type().String()
ptr := v.Pointer()
if dstMap, ok := pointers[ptr]; ok {
if dst, ok := dstMap[typeName]; ok {
return dst
}
}
dst := reflect.New(v.Type().Elem())
if pointers[ptr] == nil {
pointers[ptr] = make(map[string]reflect.Value)
}
pointers[ptr][typeName] = dst
dst.Elem().Set(_x.recursiveCopy(v.Elem(), pointers))
return dst
case reflect.Slice:
dst := reflect.MakeSlice(v.Type(), v.Len(), v.Cap())
for i := 0; i < v.Len(); i++ {
dst.Index(i).Set(_x.recursiveCopy(v.Index(i), pointers))
}
return dst
case reflect.Struct:
dst := reflect.New(v.Type()).Elem()
for i := 0; i < v.NumField(); i++ {
elem := v.Field(i)
_x.disableRO(&elem)
elemDst := _x.recursiveCopy(elem, pointers)
dstField := dst.Field(i)
_x.disableRO(&dstField)
dstField.Set(elemDst)
}
return dst
default:
return reflect.Zero(v.Type())
}
}
{{range .ServiceMethods}}
    func(_x *{{$service}}) {{.Name}}({{range $i, $x := .Param}}{{if $i}}, {{end}}p{{$i}} {{$x}}{{end}})({{range $i, $x := .Result}}{{if $i}}, {{end}}{{$x}}{{end}}){
    {{if eq .Name (print "Add" $originalClient)}}
        cc := &{{$client}}{
        service: _x,
        delegate: p1,
        msgChan: make(chan any),
        }
        go cc.run()
        p1 = cc
        _x.clients[p0] = cc
    {{else if eq .Name (print "Remove" $originalClient)}}
        c, ok := _x.clients[p0]
        if !ok {
        return
        }
        c.closeChan <- struct{}{}
        delete(_x.clients, p0)
    {{else if eq .Name "Close"}}
        _x.closeChan<-struct{}{}
    {{end}}
    msg := &_genMsg{{.Name}}{ {{range $i, $x := .Param}}{{if $i}}, {{end}}p{{$i}}: p{{$i}}{{end}}}
    _x.sendAndWait(msg)
    return {{range $i, $x := .Result}}{{if $i}}, {{end}}msg.r{{$i}}{{end}}
    }
{{end}}
func (_x *{{$service}}) sendAndWait(msg any) {
_x.msgChan <- msg
<-_x.respChan
}
type (
{{range .ServiceMethods}}
    _genMsg{{.Name}} struct {
    {{range $i, $x := .Param}}p{{$i}} {{$x}}
    {{end}}{{range $i, $x := .Result}}r{{$i}} {{$x}}
    {{end}}
    }
{{end}}
{{range .ClientMethods}}
    _genNotify{{.Name}} struct {
    {{range $i, $x := .Param}}p{{$i}} {{$x}}
    {{end}}
    }
{{end}}
)
func (_x *{{$service}}) run() {
for {
select {
case <-_x.closeChan:
close(_x.msgChan)
close(_x.respChan)
close(_x.closeChan)
return
case receivedMsg := <-_x.msgChan:
switch msg := receivedMsg.(type) {
{{range .ServiceMethods}}case *_genMsg{{.Name}}:
{{if .HasReturnedErr}} _x.wrap(&msg.r{{Add (len .Result) -1}}, func() { {{end}}
{{if .Result}}{{range $i, $x := .Result}}{{if $i}}, {{end}}msg.r{{$i}}{{end}} = {{end}} _x.delegate.{{.Name}}({{range $i, $x := .Param}}{{if $i}}, {{end}}msg.p{{$i}}{{end}})
{{if .Result}}
    {{range $i, $x := .Result}}{{if $i}}, {{end}}msg.r{{$i}}{{end}} = {{range $i, $x := .Result}}{{if $i}}, {{end}}_x.copy(msg.r{{$i}}).({{$x}}){{end}}
{{end}}
{{if .HasReturnedErr}} }){{end}}
{{end}}}
_x.respChan <- struct{}{}
}
}
}

func (_x *{{$service}}) wrap(err *error, f func()) {
defer func() {
if r := recover(); r != nil {
if rr, ok := r.(error); ok {
*err = rr
} else {
*err = fmt.Errorf("panic: %v", r)
}
}
}()
f()
}